schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
expression to compare columns of type Float. All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

type InsertAreaOfInterestActionOutput {
  areaOfInterest: area_of_interest
  areaOfInterestId: uuid!
}

"""
expression to compare columns of type Int. All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

type TileSetInfoOutput {
  size: Int
  tileSet: tile_set
  tileSetId: ID!
}

"""
columns and relationships of "area_of_interest"
"""
type area_of_interest {
  id: uuid!
  maxZoom: Int
  minZoom: Int
  name: String!
  source(
    """
    JSON select path
    """
    path: String
  ): jsonb!

  """
  An array relationship
  """
  tileSets(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): [tile_set!]!

  """
  An aggregated array relationship
  """
  tileSets_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): tile_set_aggregate!
  tilesCount: numeric

  """
  An object relationship
  """
  user: users
  userId: uuid
  xyzCoordinates(
    """
    JSON select path
    """
    path: String
  ): jsonb
}

"""
aggregated selection of "area_of_interest"
"""
type area_of_interest_aggregate {
  aggregate: area_of_interest_aggregate_fields
  nodes: [area_of_interest!]!
}

"""
aggregate fields of "area_of_interest"
"""
type area_of_interest_aggregate_fields {
  avg: area_of_interest_avg_fields
  count(columns: [area_of_interest_select_column!], distinct: Boolean): Int
  max: area_of_interest_max_fields
  min: area_of_interest_min_fields
  stddev: area_of_interest_stddev_fields
  stddev_pop: area_of_interest_stddev_pop_fields
  stddev_samp: area_of_interest_stddev_samp_fields
  sum: area_of_interest_sum_fields
  var_pop: area_of_interest_var_pop_fields
  var_samp: area_of_interest_var_samp_fields
  variance: area_of_interest_variance_fields
}

"""
order by aggregate values of table "area_of_interest"
"""
input area_of_interest_aggregate_order_by {
  avg: area_of_interest_avg_order_by
  count: order_by
  max: area_of_interest_max_order_by
  min: area_of_interest_min_order_by
  stddev: area_of_interest_stddev_order_by
  stddev_pop: area_of_interest_stddev_pop_order_by
  stddev_samp: area_of_interest_stddev_samp_order_by
  sum: area_of_interest_sum_order_by
  var_pop: area_of_interest_var_pop_order_by
  var_samp: area_of_interest_var_samp_order_by
  variance: area_of_interest_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input area_of_interest_append_input {
  source: jsonb
  xyzCoordinates: jsonb
}

"""
input type for inserting array relation for remote table "area_of_interest"
"""
input area_of_interest_arr_rel_insert_input {
  data: [area_of_interest_insert_input!]!
  on_conflict: area_of_interest_on_conflict
}

"""
aggregate avg on columns
"""
type area_of_interest_avg_fields {
  maxZoom: Float
  minZoom: Float
  tilesCount: Float
}

"""
order by avg() on columns of table "area_of_interest"
"""
input area_of_interest_avg_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
Boolean expression to filter rows from the table "area_of_interest". All fields are combined with a logical 'AND'.
"""
input area_of_interest_bool_exp {
  _and: [area_of_interest_bool_exp]
  _not: area_of_interest_bool_exp
  _or: [area_of_interest_bool_exp]
  id: uuid_comparison_exp
  maxZoom: Int_comparison_exp
  minZoom: Int_comparison_exp
  name: String_comparison_exp
  source: jsonb_comparison_exp
  tileSets: tile_set_bool_exp
  tilesCount: numeric_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
  xyzCoordinates: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "area_of_interest"
"""
enum area_of_interest_constraint {
  """
  unique or primary key constraint
  """
  area_of_interest_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input area_of_interest_delete_at_path_input {
  source: [String]
  xyzCoordinates: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input area_of_interest_delete_elem_input {
  source: Int
  xyzCoordinates: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input area_of_interest_delete_key_input {
  source: String
  xyzCoordinates: String
}

"""
input type for incrementing integer column in table "area_of_interest"
"""
input area_of_interest_inc_input {
  maxZoom: Int
  minZoom: Int
  tilesCount: numeric
}

"""
input type for inserting data into table "area_of_interest"
"""
input area_of_interest_insert_input {
  id: uuid
  maxZoom: Int
  minZoom: Int
  name: String
  source: jsonb
  tileSets: tile_set_arr_rel_insert_input
  tilesCount: numeric
  user: users_obj_rel_insert_input
  userId: uuid
  xyzCoordinates: jsonb
}

"""
aggregate max on columns
"""
type area_of_interest_max_fields {
  id: uuid
  maxZoom: Int
  minZoom: Int
  name: String
  tilesCount: numeric
  userId: uuid
}

"""
order by max() on columns of table "area_of_interest"
"""
input area_of_interest_max_order_by {
  id: order_by
  maxZoom: order_by
  minZoom: order_by
  name: order_by
  tilesCount: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type area_of_interest_min_fields {
  id: uuid
  maxZoom: Int
  minZoom: Int
  name: String
  tilesCount: numeric
  userId: uuid
}

"""
order by min() on columns of table "area_of_interest"
"""
input area_of_interest_min_order_by {
  id: order_by
  maxZoom: order_by
  minZoom: order_by
  name: order_by
  tilesCount: order_by
  userId: order_by
}

"""
response of any mutation on the table "area_of_interest"
"""
type area_of_interest_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [area_of_interest!]!
}

"""
input type for inserting object relation for remote table "area_of_interest"
"""
input area_of_interest_obj_rel_insert_input {
  data: area_of_interest_insert_input!
  on_conflict: area_of_interest_on_conflict
}

"""
on conflict condition type for table "area_of_interest"
"""
input area_of_interest_on_conflict {
  constraint: area_of_interest_constraint!
  update_columns: [area_of_interest_update_column!]!
  where: area_of_interest_bool_exp
}

"""
ordering options when selecting data from "area_of_interest"
"""
input area_of_interest_order_by {
  id: order_by
  maxZoom: order_by
  minZoom: order_by
  name: order_by
  source: order_by
  tileSets_aggregate: tile_set_aggregate_order_by
  tilesCount: order_by
  user: users_order_by
  userId: order_by
  xyzCoordinates: order_by
}

"""
primary key columns input for table: "area_of_interest"
"""
input area_of_interest_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input area_of_interest_prepend_input {
  source: jsonb
  xyzCoordinates: jsonb
}

"""
select columns of table "area_of_interest"
"""
enum area_of_interest_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  maxZoom

  """
  column name
  """
  minZoom

  """
  column name
  """
  name

  """
  column name
  """
  source

  """
  column name
  """
  tilesCount

  """
  column name
  """
  userId

  """
  column name
  """
  xyzCoordinates
}

"""
input type for updating data in table "area_of_interest"
"""
input area_of_interest_set_input {
  id: uuid
  maxZoom: Int
  minZoom: Int
  name: String
  source: jsonb
  tilesCount: numeric
  userId: uuid
  xyzCoordinates: jsonb
}

"""
aggregate stddev on columns
"""
type area_of_interest_stddev_fields {
  maxZoom: Float
  minZoom: Float
  tilesCount: Float
}

"""
order by stddev() on columns of table "area_of_interest"
"""
input area_of_interest_stddev_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
aggregate stddev_pop on columns
"""
type area_of_interest_stddev_pop_fields {
  maxZoom: Float
  minZoom: Float
  tilesCount: Float
}

"""
order by stddev_pop() on columns of table "area_of_interest"
"""
input area_of_interest_stddev_pop_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
aggregate stddev_samp on columns
"""
type area_of_interest_stddev_samp_fields {
  maxZoom: Float
  minZoom: Float
  tilesCount: Float
}

"""
order by stddev_samp() on columns of table "area_of_interest"
"""
input area_of_interest_stddev_samp_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
aggregate sum on columns
"""
type area_of_interest_sum_fields {
  maxZoom: Int
  minZoom: Int
  tilesCount: numeric
}

"""
order by sum() on columns of table "area_of_interest"
"""
input area_of_interest_sum_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
update columns of table "area_of_interest"
"""
enum area_of_interest_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  maxZoom

  """
  column name
  """
  minZoom

  """
  column name
  """
  name

  """
  column name
  """
  source

  """
  column name
  """
  tilesCount

  """
  column name
  """
  userId

  """
  column name
  """
  xyzCoordinates
}

"""
aggregate var_pop on columns
"""
type area_of_interest_var_pop_fields {
  maxZoom: Float
  minZoom: Float
  tilesCount: Float
}

"""
order by var_pop() on columns of table "area_of_interest"
"""
input area_of_interest_var_pop_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
aggregate var_samp on columns
"""
type area_of_interest_var_samp_fields {
  maxZoom: Float
  minZoom: Float
  tilesCount: Float
}

"""
order by var_samp() on columns of table "area_of_interest"
"""
input area_of_interest_var_samp_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
aggregate variance on columns
"""
type area_of_interest_variance_fields {
  maxZoom: Float
  minZoom: Float
  tilesCount: Float
}

"""
order by variance() on columns of table "area_of_interest"
"""
input area_of_interest_variance_order_by {
  maxZoom: order_by
  minZoom: order_by
  tilesCount: order_by
}

"""
columns and relationships of "auth.account_providers"
"""
type auth_account_providers {
  """
  An object relationship
  """
  account: auth_accounts!
  account_id: uuid!
  auth_provider: String!
  auth_provider_unique_id: String!
  created_at: timestamptz!
  id: uuid!

  """
  An object relationship
  """
  provider: auth_providers!
  updated_at: timestamptz!
}

"""
aggregated selection of "auth.account_providers"
"""
type auth_account_providers_aggregate {
  aggregate: auth_account_providers_aggregate_fields
  nodes: [auth_account_providers!]!
}

"""
aggregate fields of "auth.account_providers"
"""
type auth_account_providers_aggregate_fields {
  count(
    columns: [auth_account_providers_select_column!]
    distinct: Boolean
  ): Int
  max: auth_account_providers_max_fields
  min: auth_account_providers_min_fields
}

"""
order by aggregate values of table "auth.account_providers"
"""
input auth_account_providers_aggregate_order_by {
  count: order_by
  max: auth_account_providers_max_order_by
  min: auth_account_providers_min_order_by
}

"""
input type for inserting array relation for remote table "auth.account_providers"
"""
input auth_account_providers_arr_rel_insert_input {
  data: [auth_account_providers_insert_input!]!
  on_conflict: auth_account_providers_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.account_providers". All fields are combined with a logical 'AND'.
"""
input auth_account_providers_bool_exp {
  _and: [auth_account_providers_bool_exp]
  _not: auth_account_providers_bool_exp
  _or: [auth_account_providers_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  auth_provider: String_comparison_exp
  auth_provider_unique_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: auth_providers_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.account_providers"
"""
enum auth_account_providers_constraint {
  """
  unique or primary key constraint
  """
  account_providers_account_id_auth_provider_key

  """
  unique or primary key constraint
  """
  account_providers_auth_provider_auth_provider_unique_id_key

  """
  unique or primary key constraint
  """
  account_providers_pkey
}

"""
input type for inserting data into table "auth.account_providers"
"""
input auth_account_providers_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  provider: auth_providers_obj_rel_insert_input
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type auth_account_providers_max_fields {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "auth.account_providers"
"""
input auth_account_providers_max_order_by {
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
aggregate min on columns
"""
type auth_account_providers_min_fields {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "auth.account_providers"
"""
input auth_account_providers_min_order_by {
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "auth.account_providers"
"""
type auth_account_providers_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [auth_account_providers!]!
}

"""
input type for inserting object relation for remote table "auth.account_providers"
"""
input auth_account_providers_obj_rel_insert_input {
  data: auth_account_providers_insert_input!
  on_conflict: auth_account_providers_on_conflict
}

"""
on conflict condition type for table "auth.account_providers"
"""
input auth_account_providers_on_conflict {
  constraint: auth_account_providers_constraint!
  update_columns: [auth_account_providers_update_column!]!
  where: auth_account_providers_bool_exp
}

"""
ordering options when selecting data from "auth.account_providers"
"""
input auth_account_providers_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  provider: auth_providers_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "auth.account_providers"
"""
input auth_account_providers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.account_providers"
"""
enum auth_account_providers_select_column {
  """
  column name
  """
  account_id

  """
  column name
  """
  auth_provider

  """
  column name
  """
  auth_provider_unique_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "auth.account_providers"
"""
input auth_account_providers_set_input {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "auth.account_providers"
"""
enum auth_account_providers_update_column {
  """
  column name
  """
  account_id

  """
  column name
  """
  auth_provider

  """
  column name
  """
  auth_provider_unique_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  updated_at
}

"""
columns and relationships of "auth.account_roles"
"""
type auth_account_roles {
  """
  An object relationship
  """
  account: auth_accounts!
  account_id: uuid!
  created_at: timestamptz!
  id: uuid!
  role: String!

  """
  An object relationship
  """
  roleByRole: auth_roles!
}

"""
aggregated selection of "auth.account_roles"
"""
type auth_account_roles_aggregate {
  aggregate: auth_account_roles_aggregate_fields
  nodes: [auth_account_roles!]!
}

"""
aggregate fields of "auth.account_roles"
"""
type auth_account_roles_aggregate_fields {
  count(columns: [auth_account_roles_select_column!], distinct: Boolean): Int
  max: auth_account_roles_max_fields
  min: auth_account_roles_min_fields
}

"""
order by aggregate values of table "auth.account_roles"
"""
input auth_account_roles_aggregate_order_by {
  count: order_by
  max: auth_account_roles_max_order_by
  min: auth_account_roles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.account_roles"
"""
input auth_account_roles_arr_rel_insert_input {
  data: [auth_account_roles_insert_input!]!
  on_conflict: auth_account_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.account_roles". All fields are combined with a logical 'AND'.
"""
input auth_account_roles_bool_exp {
  _and: [auth_account_roles_bool_exp]
  _not: auth_account_roles_bool_exp
  _or: [auth_account_roles_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: auth_roles_bool_exp
}

"""
unique or primary key constraints on table "auth.account_roles"
"""
enum auth_account_roles_constraint {
  """
  unique or primary key constraint
  """
  account_roles_pkey

  """
  unique or primary key constraint
  """
  user_roles_account_id_role_key
}

"""
input type for inserting data into table "auth.account_roles"
"""
input auth_account_roles_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
  roleByRole: auth_roles_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type auth_account_roles_max_fields {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
order by max() on columns of table "auth.account_roles"
"""
input auth_account_roles_max_order_by {
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
}

"""
aggregate min on columns
"""
type auth_account_roles_min_fields {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
order by min() on columns of table "auth.account_roles"
"""
input auth_account_roles_min_order_by {
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
}

"""
response of any mutation on the table "auth.account_roles"
"""
type auth_account_roles_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [auth_account_roles!]!
}

"""
input type for inserting object relation for remote table "auth.account_roles"
"""
input auth_account_roles_obj_rel_insert_input {
  data: auth_account_roles_insert_input!
  on_conflict: auth_account_roles_on_conflict
}

"""
on conflict condition type for table "auth.account_roles"
"""
input auth_account_roles_on_conflict {
  constraint: auth_account_roles_constraint!
  update_columns: [auth_account_roles_update_column!]!
  where: auth_account_roles_bool_exp
}

"""
ordering options when selecting data from "auth.account_roles"
"""
input auth_account_roles_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
  roleByRole: auth_roles_order_by
}

"""
primary key columns input for table: "auth.account_roles"
"""
input auth_account_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.account_roles"
"""
enum auth_account_roles_select_column {
  """
  column name
  """
  account_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  role
}

"""
input type for updating data in table "auth.account_roles"
"""
input auth_account_roles_set_input {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
update columns of table "auth.account_roles"
"""
enum auth_account_roles_update_column {
  """
  column name
  """
  account_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  role
}

"""
columns and relationships of "auth.accounts"
"""
type auth_accounts {
  """
  An array relationship
  """
  account_providers(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  An aggregated array relationship
  """
  account_providers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """
  An array relationship
  """
  account_roles(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  An aggregated array relationship
  """
  account_roles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!
  active: Boolean!
  created_at: timestamptz!
  custom_register_data(
    """
    JSON select path
    """
    path: String
  ): jsonb
  default_role: String!
  email: citext
  id: uuid!
  is_anonymous: Boolean!
  mfa_enabled: Boolean!
  new_email: citext
  otp_secret: String
  password_hash: String

  """
  An array relationship
  """
  refresh_tokens(
    """
    distinct select on columns
    """
    distinct_on: [auth_refresh_tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_refresh_tokens_order_by!]

    """
    filter the rows returned
    """
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  An aggregated array relationship
  """
  refresh_tokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_refresh_tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_refresh_tokens_order_by!]

    """
    filter the rows returned
    """
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  An object relationship
  """
  role: auth_roles!
  ticket: uuid!
  ticket_expires_at: timestamptz!
  updated_at: timestamptz!

  """
  An object relationship
  """
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "auth.accounts"
"""
type auth_accounts_aggregate {
  aggregate: auth_accounts_aggregate_fields
  nodes: [auth_accounts!]!
}

"""
aggregate fields of "auth.accounts"
"""
type auth_accounts_aggregate_fields {
  count(columns: [auth_accounts_select_column!], distinct: Boolean): Int
  max: auth_accounts_max_fields
  min: auth_accounts_min_fields
}

"""
order by aggregate values of table "auth.accounts"
"""
input auth_accounts_aggregate_order_by {
  count: order_by
  max: auth_accounts_max_order_by
  min: auth_accounts_min_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input auth_accounts_append_input {
  custom_register_data: jsonb
}

"""
input type for inserting array relation for remote table "auth.accounts"
"""
input auth_accounts_arr_rel_insert_input {
  data: [auth_accounts_insert_input!]!
  on_conflict: auth_accounts_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.accounts". All fields are combined with a logical 'AND'.
"""
input auth_accounts_bool_exp {
  _and: [auth_accounts_bool_exp]
  _not: auth_accounts_bool_exp
  _or: [auth_accounts_bool_exp]
  account_providers: auth_account_providers_bool_exp
  account_roles: auth_account_roles_bool_exp
  active: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  custom_register_data: jsonb_comparison_exp
  default_role: String_comparison_exp
  email: citext_comparison_exp
  id: uuid_comparison_exp
  is_anonymous: Boolean_comparison_exp
  mfa_enabled: Boolean_comparison_exp
  new_email: citext_comparison_exp
  otp_secret: String_comparison_exp
  password_hash: String_comparison_exp
  refresh_tokens: auth_refresh_tokens_bool_exp
  role: auth_roles_bool_exp
  ticket: uuid_comparison_exp
  ticket_expires_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.accounts"
"""
enum auth_accounts_constraint {
  """
  unique or primary key constraint
  """
  accounts_email_key

  """
  unique or primary key constraint
  """
  accounts_new_email_key

  """
  unique or primary key constraint
  """
  accounts_pkey

  """
  unique or primary key constraint
  """
  accounts_user_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_accounts_delete_at_path_input {
  custom_register_data: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_accounts_delete_elem_input {
  custom_register_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_accounts_delete_key_input {
  custom_register_data: String
}

"""
input type for inserting data into table "auth.accounts"
"""
input auth_accounts_insert_input {
  account_providers: auth_account_providers_arr_rel_insert_input
  account_roles: auth_account_roles_arr_rel_insert_input
  active: Boolean
  created_at: timestamptz
  custom_register_data: jsonb
  default_role: String
  email: citext
  id: uuid
  is_anonymous: Boolean
  mfa_enabled: Boolean
  new_email: citext
  otp_secret: String
  password_hash: String
  refresh_tokens: auth_refresh_tokens_arr_rel_insert_input
  role: auth_roles_obj_rel_insert_input
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type auth_accounts_max_fields {
  created_at: timestamptz
  default_role: String
  email: citext
  id: uuid
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "auth.accounts"
"""
input auth_accounts_max_order_by {
  created_at: order_by
  default_role: order_by
  email: order_by
  id: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type auth_accounts_min_fields {
  created_at: timestamptz
  default_role: String
  email: citext
  id: uuid
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "auth.accounts"
"""
input auth_accounts_min_order_by {
  created_at: order_by
  default_role: order_by
  email: order_by
  id: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "auth.accounts"
"""
type auth_accounts_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [auth_accounts!]!
}

"""
input type for inserting object relation for remote table "auth.accounts"
"""
input auth_accounts_obj_rel_insert_input {
  data: auth_accounts_insert_input!
  on_conflict: auth_accounts_on_conflict
}

"""
on conflict condition type for table "auth.accounts"
"""
input auth_accounts_on_conflict {
  constraint: auth_accounts_constraint!
  update_columns: [auth_accounts_update_column!]!
  where: auth_accounts_bool_exp
}

"""
ordering options when selecting data from "auth.accounts"
"""
input auth_accounts_order_by {
  account_providers_aggregate: auth_account_providers_aggregate_order_by
  account_roles_aggregate: auth_account_roles_aggregate_order_by
  active: order_by
  created_at: order_by
  custom_register_data: order_by
  default_role: order_by
  email: order_by
  id: order_by
  is_anonymous: order_by
  mfa_enabled: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  refresh_tokens_aggregate: auth_refresh_tokens_aggregate_order_by
  role: auth_roles_order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""
primary key columns input for table: "auth.accounts"
"""
input auth_accounts_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input auth_accounts_prepend_input {
  custom_register_data: jsonb
}

"""
select columns of table "auth.accounts"
"""
enum auth_accounts_select_column {
  """
  column name
  """
  active

  """
  column name
  """
  created_at

  """
  column name
  """
  custom_register_data

  """
  column name
  """
  default_role

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  is_anonymous

  """
  column name
  """
  mfa_enabled

  """
  column name
  """
  new_email

  """
  column name
  """
  otp_secret

  """
  column name
  """
  password_hash

  """
  column name
  """
  ticket

  """
  column name
  """
  ticket_expires_at

  """
  column name
  """
  updated_at

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "auth.accounts"
"""
input auth_accounts_set_input {
  active: Boolean
  created_at: timestamptz
  custom_register_data: jsonb
  default_role: String
  email: citext
  id: uuid
  is_anonymous: Boolean
  mfa_enabled: Boolean
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "auth.accounts"
"""
enum auth_accounts_update_column {
  """
  column name
  """
  active

  """
  column name
  """
  created_at

  """
  column name
  """
  custom_register_data

  """
  column name
  """
  default_role

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  is_anonymous

  """
  column name
  """
  mfa_enabled

  """
  column name
  """
  new_email

  """
  column name
  """
  otp_secret

  """
  column name
  """
  password_hash

  """
  column name
  """
  ticket

  """
  column name
  """
  ticket_expires_at

  """
  column name
  """
  updated_at

  """
  column name
  """
  user_id
}

"""
columns and relationships of "auth.providers"
"""
type auth_providers {
  """
  An array relationship
  """
  account_providers(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  An aggregated array relationship
  """
  account_providers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!
  provider: String!
}

"""
aggregated selection of "auth.providers"
"""
type auth_providers_aggregate {
  aggregate: auth_providers_aggregate_fields
  nodes: [auth_providers!]!
}

"""
aggregate fields of "auth.providers"
"""
type auth_providers_aggregate_fields {
  count(columns: [auth_providers_select_column!], distinct: Boolean): Int
  max: auth_providers_max_fields
  min: auth_providers_min_fields
}

"""
order by aggregate values of table "auth.providers"
"""
input auth_providers_aggregate_order_by {
  count: order_by
  max: auth_providers_max_order_by
  min: auth_providers_min_order_by
}

"""
input type for inserting array relation for remote table "auth.providers"
"""
input auth_providers_arr_rel_insert_input {
  data: [auth_providers_insert_input!]!
  on_conflict: auth_providers_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input auth_providers_bool_exp {
  _and: [auth_providers_bool_exp]
  _not: auth_providers_bool_exp
  _or: [auth_providers_bool_exp]
  account_providers: auth_account_providers_bool_exp
  provider: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum auth_providers_constraint {
  """
  unique or primary key constraint
  """
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input auth_providers_insert_input {
  account_providers: auth_account_providers_arr_rel_insert_input
  provider: String
}

"""
aggregate max on columns
"""
type auth_providers_max_fields {
  provider: String
}

"""
order by max() on columns of table "auth.providers"
"""
input auth_providers_max_order_by {
  provider: order_by
}

"""
aggregate min on columns
"""
type auth_providers_min_fields {
  provider: String
}

"""
order by min() on columns of table "auth.providers"
"""
input auth_providers_min_order_by {
  provider: order_by
}

"""
response of any mutation on the table "auth.providers"
"""
type auth_providers_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [auth_providers!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input auth_providers_obj_rel_insert_input {
  data: auth_providers_insert_input!
  on_conflict: auth_providers_on_conflict
}

"""
on conflict condition type for table "auth.providers"
"""
input auth_providers_on_conflict {
  constraint: auth_providers_constraint!
  update_columns: [auth_providers_update_column!]!
  where: auth_providers_bool_exp
}

"""
ordering options when selecting data from "auth.providers"
"""
input auth_providers_order_by {
  account_providers_aggregate: auth_account_providers_aggregate_order_by
  provider: order_by
}

"""
primary key columns input for table: "auth.providers"
"""
input auth_providers_pk_columns_input {
  provider: String!
}

"""
select columns of table "auth.providers"
"""
enum auth_providers_select_column {
  """
  column name
  """
  provider
}

"""
input type for updating data in table "auth.providers"
"""
input auth_providers_set_input {
  provider: String
}

"""
update columns of table "auth.providers"
"""
enum auth_providers_update_column {
  """
  column name
  """
  provider
}

"""
columns and relationships of "auth.refresh_tokens"
"""
type auth_refresh_tokens {
  """
  An object relationship
  """
  account: auth_accounts!
  account_id: uuid!
  created_at: timestamptz!
  expires_at: timestamptz!
  refresh_token: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate {
  aggregate: auth_refresh_tokens_aggregate_fields
  nodes: [auth_refresh_tokens!]!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate_fields {
  count(columns: [auth_refresh_tokens_select_column!], distinct: Boolean): Int
  max: auth_refresh_tokens_max_fields
  min: auth_refresh_tokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_aggregate_order_by {
  count: order_by
  max: auth_refresh_tokens_max_order_by
  min: auth_refresh_tokens_min_order_by
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input auth_refresh_tokens_arr_rel_insert_input {
  data: [auth_refresh_tokens_insert_input!]!
  on_conflict: auth_refresh_tokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input auth_refresh_tokens_bool_exp {
  _and: [auth_refresh_tokens_bool_exp]
  _not: auth_refresh_tokens_bool_exp
  _or: [auth_refresh_tokens_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  expires_at: timestamptz_comparison_exp
  refresh_token: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_constraint {
  """
  unique or primary key constraint
  """
  refresh_tokens_pkey
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input auth_refresh_tokens_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
aggregate max on columns
"""
type auth_refresh_tokens_max_fields {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_max_order_by {
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""
aggregate min on columns
"""
type auth_refresh_tokens_min_fields {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_min_order_by {
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type auth_refresh_tokens_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [auth_refresh_tokens!]!
}

"""
input type for inserting object relation for remote table "auth.refresh_tokens"
"""
input auth_refresh_tokens_obj_rel_insert_input {
  data: auth_refresh_tokens_insert_input!
  on_conflict: auth_refresh_tokens_on_conflict
}

"""
on conflict condition type for table "auth.refresh_tokens"
"""
input auth_refresh_tokens_on_conflict {
  constraint: auth_refresh_tokens_constraint!
  update_columns: [auth_refresh_tokens_update_column!]!
  where: auth_refresh_tokens_bool_exp
}

"""
ordering options when selecting data from "auth.refresh_tokens"
"""
input auth_refresh_tokens_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""
primary key columns input for table: "auth.refresh_tokens"
"""
input auth_refresh_tokens_pk_columns_input {
  refresh_token: uuid!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_select_column {
  """
  column name
  """
  account_id

  """
  column name
  """
  created_at

  """
  column name
  """
  expires_at

  """
  column name
  """
  refresh_token
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input auth_refresh_tokens_set_input {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_update_column {
  """
  column name
  """
  account_id

  """
  column name
  """
  created_at

  """
  column name
  """
  expires_at

  """
  column name
  """
  refresh_token
}

"""
columns and relationships of "auth.roles"
"""
type auth_roles {
  """
  An array relationship
  """
  account_roles(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  An aggregated array relationship
  """
  account_roles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """
  An array relationship
  """
  accounts(
    """
    distinct select on columns
    """
    distinct_on: [auth_accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_accounts_order_by!]

    """
    filter the rows returned
    """
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """
  An aggregated array relationship
  """
  accounts_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_accounts_order_by!]

    """
    filter the rows returned
    """
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!
  role: String!
}

"""
aggregated selection of "auth.roles"
"""
type auth_roles_aggregate {
  aggregate: auth_roles_aggregate_fields
  nodes: [auth_roles!]!
}

"""
aggregate fields of "auth.roles"
"""
type auth_roles_aggregate_fields {
  count(columns: [auth_roles_select_column!], distinct: Boolean): Int
  max: auth_roles_max_fields
  min: auth_roles_min_fields
}

"""
order by aggregate values of table "auth.roles"
"""
input auth_roles_aggregate_order_by {
  count: order_by
  max: auth_roles_max_order_by
  min: auth_roles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.roles"
"""
input auth_roles_arr_rel_insert_input {
  data: [auth_roles_insert_input!]!
  on_conflict: auth_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input auth_roles_bool_exp {
  _and: [auth_roles_bool_exp]
  _not: auth_roles_bool_exp
  _or: [auth_roles_bool_exp]
  account_roles: auth_account_roles_bool_exp
  accounts: auth_accounts_bool_exp
  role: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum auth_roles_constraint {
  """
  unique or primary key constraint
  """
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input auth_roles_insert_input {
  account_roles: auth_account_roles_arr_rel_insert_input
  accounts: auth_accounts_arr_rel_insert_input
  role: String
}

"""
aggregate max on columns
"""
type auth_roles_max_fields {
  role: String
}

"""
order by max() on columns of table "auth.roles"
"""
input auth_roles_max_order_by {
  role: order_by
}

"""
aggregate min on columns
"""
type auth_roles_min_fields {
  role: String
}

"""
order by min() on columns of table "auth.roles"
"""
input auth_roles_min_order_by {
  role: order_by
}

"""
response of any mutation on the table "auth.roles"
"""
type auth_roles_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [auth_roles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input auth_roles_obj_rel_insert_input {
  data: auth_roles_insert_input!
  on_conflict: auth_roles_on_conflict
}

"""
on conflict condition type for table "auth.roles"
"""
input auth_roles_on_conflict {
  constraint: auth_roles_constraint!
  update_columns: [auth_roles_update_column!]!
  where: auth_roles_bool_exp
}

"""
ordering options when selecting data from "auth.roles"
"""
input auth_roles_order_by {
  account_roles_aggregate: auth_account_roles_aggregate_order_by
  accounts_aggregate: auth_accounts_aggregate_order_by
  role: order_by
}

"""
primary key columns input for table: "auth.roles"
"""
input auth_roles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum auth_roles_select_column {
  """
  column name
  """
  role
}

"""
input type for updating data in table "auth.roles"
"""
input auth_roles_set_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum auth_roles_update_column {
  """
  column name
  """
  role
}

scalar citext

"""
expression to compare columns of type citext. All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext
  _ilike: String
  _in: [citext!]
  _is_null: Boolean
  _like: String
  _lt: citext
  _lte: citext
  _neq: citext
  _nilike: String
  _nin: [citext!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

scalar jsonb

"""
expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
mutation root
"""
type mutation_root {
  """
  delete single row from the table: "area_of_interest"
  """
  deleteAreaOfInterest(id: uuid!): area_of_interest

  """
  delete data from the table: "area_of_interest"
  """
  deleteAreaOfInterests(
    """
    filter the rows which have to be deleted
    """
    where: area_of_interest_bool_exp!
  ): area_of_interest_mutation_response

  """
  delete single row from the table: "tile_provider"
  """
  deleteTileProvider(id: uuid!): tile_provider

  """
  delete data from the table: "tile_provider"
  """
  deleteTileProviders(
    """
    filter the rows which have to be deleted
    """
    where: tile_provider_bool_exp!
  ): tile_provider_mutation_response

  """
  delete single row from the table: "tile_set"
  """
  deleteTileSet(id: uuid!): tile_set

  """
  delete data from the table: "tile_set"
  """
  deleteTileSets(
    """
    filter the rows which have to be deleted
    """
    where: tile_set_bool_exp!
  ): tile_set_mutation_response

  """
  delete data from the table: "auth.account_providers"
  """
  delete_auth_account_providers(
    """
    filter the rows which have to be deleted
    """
    where: auth_account_providers_bool_exp!
  ): auth_account_providers_mutation_response

  """
  delete single row from the table: "auth.account_providers"
  """
  delete_auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  delete data from the table: "auth.account_roles"
  """
  delete_auth_account_roles(
    """
    filter the rows which have to be deleted
    """
    where: auth_account_roles_bool_exp!
  ): auth_account_roles_mutation_response

  """
  delete single row from the table: "auth.account_roles"
  """
  delete_auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  delete data from the table: "auth.accounts"
  """
  delete_auth_accounts(
    """
    filter the rows which have to be deleted
    """
    where: auth_accounts_bool_exp!
  ): auth_accounts_mutation_response

  """
  delete single row from the table: "auth.accounts"
  """
  delete_auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  delete data from the table: "auth.providers"
  """
  delete_auth_providers(
    """
    filter the rows which have to be deleted
    """
    where: auth_providers_bool_exp!
  ): auth_providers_mutation_response

  """
  delete single row from the table: "auth.providers"
  """
  delete_auth_providers_by_pk(provider: String!): auth_providers

  """
  delete data from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens(
    """
    filter the rows which have to be deleted
    """
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  delete data from the table: "auth.roles"
  """
  delete_auth_roles(
    """
    filter the rows which have to be deleted
    """
    where: auth_roles_bool_exp!
  ): auth_roles_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  delete_auth_roles_by_pk(role: String!): auth_roles

  """
  delete data from the table: "users"
  """
  delete_users(
    """
    filter the rows which have to be deleted
    """
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  insert a single row into the table: "area_of_interest"
  """
  insertAreaOfInterest(
    """
    the row to be inserted
    """
    object: area_of_interest_insert_input!

    """
    on conflict condition
    """
    on_conflict: area_of_interest_on_conflict
  ): area_of_interest

  """
  insert data into the table: "area_of_interest"
  """
  insertAreasOfInterest(
    """
    the rows to be inserted
    """
    objects: [area_of_interest_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: area_of_interest_on_conflict
  ): area_of_interest_mutation_response

  """
  insert a single row into the table: "tile_provider"
  """
  insertTileProvider(
    """
    the row to be inserted
    """
    object: tile_provider_insert_input!

    """
    on conflict condition
    """
    on_conflict: tile_provider_on_conflict
  ): tile_provider

  """
  insert data into the table: "tile_provider"
  """
  insertTileProviders(
    """
    the rows to be inserted
    """
    objects: [tile_provider_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tile_provider_on_conflict
  ): tile_provider_mutation_response

  """
  insert a single row into the table: "tile_set"
  """
  insertTileSet(
    """
    the row to be inserted
    """
    object: tile_set_insert_input!

    """
    on conflict condition
    """
    on_conflict: tile_set_on_conflict
  ): tile_set

  """
  insert data into the table: "tile_set"
  """
  insertTileSets(
    """
    the rows to be inserted
    """
    objects: [tile_set_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tile_set_on_conflict
  ): tile_set_mutation_response

  """
  insert data into the table: "auth.account_providers"
  """
  insert_auth_account_providers(
    """
    the rows to be inserted
    """
    objects: [auth_account_providers_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: auth_account_providers_on_conflict
  ): auth_account_providers_mutation_response

  """
  insert a single row into the table: "auth.account_providers"
  """
  insert_auth_account_providers_one(
    """
    the row to be inserted
    """
    object: auth_account_providers_insert_input!

    """
    on conflict condition
    """
    on_conflict: auth_account_providers_on_conflict
  ): auth_account_providers

  """
  insert data into the table: "auth.account_roles"
  """
  insert_auth_account_roles(
    """
    the rows to be inserted
    """
    objects: [auth_account_roles_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: auth_account_roles_on_conflict
  ): auth_account_roles_mutation_response

  """
  insert a single row into the table: "auth.account_roles"
  """
  insert_auth_account_roles_one(
    """
    the row to be inserted
    """
    object: auth_account_roles_insert_input!

    """
    on conflict condition
    """
    on_conflict: auth_account_roles_on_conflict
  ): auth_account_roles

  """
  insert data into the table: "auth.accounts"
  """
  insert_auth_accounts(
    """
    the rows to be inserted
    """
    objects: [auth_accounts_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: auth_accounts_on_conflict
  ): auth_accounts_mutation_response

  """
  insert a single row into the table: "auth.accounts"
  """
  insert_auth_accounts_one(
    """
    the row to be inserted
    """
    object: auth_accounts_insert_input!

    """
    on conflict condition
    """
    on_conflict: auth_accounts_on_conflict
  ): auth_accounts

  """
  insert data into the table: "auth.providers"
  """
  insert_auth_providers(
    """
    the rows to be inserted
    """
    objects: [auth_providers_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: auth_providers_on_conflict
  ): auth_providers_mutation_response

  """
  insert a single row into the table: "auth.providers"
  """
  insert_auth_providers_one(
    """
    the row to be inserted
    """
    object: auth_providers_insert_input!

    """
    on conflict condition
    """
    on_conflict: auth_providers_on_conflict
  ): auth_providers

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens(
    """
    the rows to be inserted
    """
    objects: [auth_refresh_tokens_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens_one(
    """
    the row to be inserted
    """
    object: auth_refresh_tokens_insert_input!

    """
    on conflict condition
    """
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens

  """
  insert data into the table: "auth.roles"
  """
  insert_auth_roles(
    """
    the rows to be inserted
    """
    objects: [auth_roles_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: auth_roles_on_conflict
  ): auth_roles_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insert_auth_roles_one(
    """
    the row to be inserted
    """
    object: auth_roles_insert_input!

    """
    on conflict condition
    """
    on_conflict: auth_roles_on_conflict
  ): auth_roles

  """
  insert data into the table: "users"
  """
  insert_users(
    """
    the rows to be inserted
    """
    objects: [users_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """
    the row to be inserted
    """
    object: users_insert_input!

    """
    on conflict condition
    """
    on_conflict: users_on_conflict
  ): users

  """
  update single row of the table: "area_of_interest"
  """
  updateAreaOfInterest(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: area_of_interest_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: area_of_interest_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: area_of_interest_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: area_of_interest_delete_key_input

    """
    increments the integer columns with given value of the filtered values
    """
    _inc: area_of_interest_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: area_of_interest_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: area_of_interest_set_input
    pk_columns: area_of_interest_pk_columns_input!
  ): area_of_interest

  """
  update data of the table: "area_of_interest"
  """
  updateAreasOfInterest(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: area_of_interest_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: area_of_interest_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: area_of_interest_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: area_of_interest_delete_key_input

    """
    increments the integer columns with given value of the filtered values
    """
    _inc: area_of_interest_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: area_of_interest_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: area_of_interest_set_input

    """
    filter the rows which have to be updated
    """
    where: area_of_interest_bool_exp!
  ): area_of_interest_mutation_response

  """
  update single row of the table: "tile_provider"
  """
  updateTileProvider(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tile_provider_set_input
    pk_columns: tile_provider_pk_columns_input!
  ): tile_provider

  """
  update data of the table: "tile_provider"
  """
  updateTileProviders(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: tile_provider_set_input

    """
    filter the rows which have to be updated
    """
    where: tile_provider_bool_exp!
  ): tile_provider_mutation_response

  """
  update single row of the table: "tile_set"
  """
  updateTileSet(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: tile_set_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: tile_set_set_input
    pk_columns: tile_set_pk_columns_input!
  ): tile_set

  """
  update data of the table: "tile_set"
  """
  updateTileSets(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: tile_set_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: tile_set_set_input

    """
    filter the rows which have to be updated
    """
    where: tile_set_bool_exp!
  ): tile_set_mutation_response

  """
  update data of the table: "auth.account_providers"
  """
  update_auth_account_providers(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_account_providers_set_input

    """
    filter the rows which have to be updated
    """
    where: auth_account_providers_bool_exp!
  ): auth_account_providers_mutation_response

  """
  update single row of the table: "auth.account_providers"
  """
  update_auth_account_providers_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_account_providers_set_input
    pk_columns: auth_account_providers_pk_columns_input!
  ): auth_account_providers

  """
  update data of the table: "auth.account_roles"
  """
  update_auth_account_roles(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_account_roles_set_input

    """
    filter the rows which have to be updated
    """
    where: auth_account_roles_bool_exp!
  ): auth_account_roles_mutation_response

  """
  update single row of the table: "auth.account_roles"
  """
  update_auth_account_roles_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_account_roles_set_input
    pk_columns: auth_account_roles_pk_columns_input!
  ): auth_account_roles

  """
  update data of the table: "auth.accounts"
  """
  update_auth_accounts(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: auth_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_accounts_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: auth_accounts_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_accounts_set_input

    """
    filter the rows which have to be updated
    """
    where: auth_accounts_bool_exp!
  ): auth_accounts_mutation_response

  """
  update single row of the table: "auth.accounts"
  """
  update_auth_accounts_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: auth_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_accounts_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: auth_accounts_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_accounts_set_input
    pk_columns: auth_accounts_pk_columns_input!
  ): auth_accounts

  """
  update data of the table: "auth.providers"
  """
  update_auth_providers(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_providers_set_input

    """
    filter the rows which have to be updated
    """
    where: auth_providers_bool_exp!
  ): auth_providers_mutation_response

  """
  update single row of the table: "auth.providers"
  """
  update_auth_providers_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_providers_set_input
    pk_columns: auth_providers_pk_columns_input!
  ): auth_providers

  """
  update data of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_refresh_tokens_set_input

    """
    filter the rows which have to be updated
    """
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_refresh_tokens_set_input
    pk_columns: auth_refresh_tokens_pk_columns_input!
  ): auth_refresh_tokens

  """
  update data of the table: "auth.roles"
  """
  update_auth_roles(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_roles_set_input

    """
    filter the rows which have to be updated
    """
    where: auth_roles_bool_exp!
  ): auth_roles_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  update_auth_roles_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: auth_roles_set_input
    pk_columns: auth_roles_pk_columns_input!
  ): auth_roles

  """
  update data of the table: "users"
  """
  update_users(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input

    """
    filter the rows which have to be updated
    """
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
}

scalar numeric

"""
expression to compare columns of type numeric. All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in the ascending order, nulls last
  """
  asc

  """
  in the ascending order, nulls first
  """
  asc_nulls_first

  """
  in the ascending order, nulls last
  """
  asc_nulls_last

  """
  in the descending order, nulls first
  """
  desc

  """
  in the descending order, nulls first
  """
  desc_nulls_first

  """
  in the descending order, nulls last
  """
  desc_nulls_last
}

"""
query root
"""
type query_root {
  """
  fetch data from the table: "area_of_interest" using primary key columns
  """
  areaOfInterest(id: uuid!): area_of_interest

  """
  fetch aggregated fields from the table: "area_of_interest"
  """
  areaOfInterestAggregate(
    """
    distinct select on columns
    """
    distinct_on: [area_of_interest_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [area_of_interest_order_by!]

    """
    filter the rows returned
    """
    where: area_of_interest_bool_exp
  ): area_of_interest_aggregate!

  """
  fetch data from the table: "area_of_interest"
  """
  areasOfInterest(
    """
    distinct select on columns
    """
    distinct_on: [area_of_interest_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [area_of_interest_order_by!]

    """
    filter the rows returned
    """
    where: area_of_interest_bool_exp
  ): [area_of_interest!]!

  """
  fetch data from the table: "auth.account_providers"
  """
  auth_account_providers(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  fetch aggregated fields from the table: "auth.account_providers"
  """
  auth_account_providers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """
  fetch data from the table: "auth.account_providers" using primary key columns
  """
  auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  fetch data from the table: "auth.account_roles"
  """
  auth_account_roles(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  fetch aggregated fields from the table: "auth.account_roles"
  """
  auth_account_roles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """
  fetch data from the table: "auth.account_roles" using primary key columns
  """
  auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  fetch data from the table: "auth.accounts"
  """
  auth_accounts(
    """
    distinct select on columns
    """
    distinct_on: [auth_accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_accounts_order_by!]

    """
    filter the rows returned
    """
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """
  fetch aggregated fields from the table: "auth.accounts"
  """
  auth_accounts_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_accounts_order_by!]

    """
    filter the rows returned
    """
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!

  """
  fetch data from the table: "auth.accounts" using primary key columns
  """
  auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  fetch data from the table: "auth.providers"
  """
  auth_providers(
    """
    distinct select on columns
    """
    distinct_on: [auth_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_providers_bool_exp
  ): [auth_providers!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  auth_providers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_providers_bool_exp
  ): auth_providers_aggregate!

  """
  fetch data from the table: "auth.providers" using primary key columns
  """
  auth_providers_by_pk(provider: String!): auth_providers

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """
    distinct select on columns
    """
    distinct_on: [auth_refresh_tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_refresh_tokens_order_by!]

    """
    filter the rows returned
    """
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_refresh_tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_refresh_tokens_order_by!]

    """
    filter the rows returned
    """
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  fetch data from the table: "auth.roles"
  """
  auth_roles(
    """
    distinct select on columns
    """
    distinct_on: [auth_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_roles_bool_exp
  ): [auth_roles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  auth_roles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_roles_bool_exp
  ): auth_roles_aggregate!

  """
  fetch data from the table: "auth.roles" using primary key columns
  """
  auth_roles_by_pk(role: String!): auth_roles

  """
  fetch data from the table: "tile_provider" using primary key columns
  """
  tileProvider(id: uuid!): tile_provider

  """
  fetch aggregated fields from the table: "tile_provider"
  """
  tileProviderAggregate(
    """
    distinct select on columns
    """
    distinct_on: [tile_provider_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_provider_order_by!]

    """
    filter the rows returned
    """
    where: tile_provider_bool_exp
  ): tile_provider_aggregate!

  """
  fetch data from the table: "tile_provider"
  """
  tileProviders(
    """
    distinct select on columns
    """
    distinct_on: [tile_provider_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_provider_order_by!]

    """
    filter the rows returned
    """
    where: tile_provider_bool_exp
  ): [tile_provider!]!

  """
  fetch data from the table: "tile_set" using primary key columns
  """
  tileSet(id: uuid!): tile_set

  """
  fetch aggregated fields from the table: "tile_set"
  """
  tileSetAggregate(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): tile_set_aggregate!

  """
  fetch data from the table: "tile_set"
  """
  tileSets(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): [tile_set!]!

  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: uuid!): users
}

scalar smallint

"""
expression to compare columns of type smallint. All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
subscription root
"""
type subscription_root {
  """
  fetch data from the table: "area_of_interest" using primary key columns
  """
  areaOfInterest(id: uuid!): area_of_interest

  """
  fetch aggregated fields from the table: "area_of_interest"
  """
  areaOfInterestAggregate(
    """
    distinct select on columns
    """
    distinct_on: [area_of_interest_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [area_of_interest_order_by!]

    """
    filter the rows returned
    """
    where: area_of_interest_bool_exp
  ): area_of_interest_aggregate!

  """
  fetch data from the table: "area_of_interest"
  """
  areasOfInterest(
    """
    distinct select on columns
    """
    distinct_on: [area_of_interest_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [area_of_interest_order_by!]

    """
    filter the rows returned
    """
    where: area_of_interest_bool_exp
  ): [area_of_interest!]!

  """
  fetch data from the table: "auth.account_providers"
  """
  auth_account_providers(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  fetch aggregated fields from the table: "auth.account_providers"
  """
  auth_account_providers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """
  fetch data from the table: "auth.account_providers" using primary key columns
  """
  auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  fetch data from the table: "auth.account_roles"
  """
  auth_account_roles(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  fetch aggregated fields from the table: "auth.account_roles"
  """
  auth_account_roles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_account_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_account_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """
  fetch data from the table: "auth.account_roles" using primary key columns
  """
  auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  fetch data from the table: "auth.accounts"
  """
  auth_accounts(
    """
    distinct select on columns
    """
    distinct_on: [auth_accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_accounts_order_by!]

    """
    filter the rows returned
    """
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """
  fetch aggregated fields from the table: "auth.accounts"
  """
  auth_accounts_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_accounts_order_by!]

    """
    filter the rows returned
    """
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!

  """
  fetch data from the table: "auth.accounts" using primary key columns
  """
  auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  fetch data from the table: "auth.providers"
  """
  auth_providers(
    """
    distinct select on columns
    """
    distinct_on: [auth_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_providers_bool_exp
  ): [auth_providers!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  auth_providers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_providers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_providers_order_by!]

    """
    filter the rows returned
    """
    where: auth_providers_bool_exp
  ): auth_providers_aggregate!

  """
  fetch data from the table: "auth.providers" using primary key columns
  """
  auth_providers_by_pk(provider: String!): auth_providers

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """
    distinct select on columns
    """
    distinct_on: [auth_refresh_tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_refresh_tokens_order_by!]

    """
    filter the rows returned
    """
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_refresh_tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_refresh_tokens_order_by!]

    """
    filter the rows returned
    """
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  fetch data from the table: "auth.roles"
  """
  auth_roles(
    """
    distinct select on columns
    """
    distinct_on: [auth_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_roles_bool_exp
  ): [auth_roles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  auth_roles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [auth_roles_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [auth_roles_order_by!]

    """
    filter the rows returned
    """
    where: auth_roles_bool_exp
  ): auth_roles_aggregate!

  """
  fetch data from the table: "auth.roles" using primary key columns
  """
  auth_roles_by_pk(role: String!): auth_roles

  """
  fetch data from the table: "tile_provider" using primary key columns
  """
  tileProvider(id: uuid!): tile_provider

  """
  fetch aggregated fields from the table: "tile_provider"
  """
  tileProviderAggregate(
    """
    distinct select on columns
    """
    distinct_on: [tile_provider_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_provider_order_by!]

    """
    filter the rows returned
    """
    where: tile_provider_bool_exp
  ): tile_provider_aggregate!

  """
  fetch data from the table: "tile_provider"
  """
  tileProviders(
    """
    distinct select on columns
    """
    distinct_on: [tile_provider_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_provider_order_by!]

    """
    filter the rows returned
    """
    where: tile_provider_bool_exp
  ): [tile_provider!]!

  """
  fetch data from the table: "tile_set" using primary key columns
  """
  tileSet(id: uuid!): tile_set

  """
  fetch aggregated fields from the table: "tile_set"
  """
  tileSetAggregate(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): tile_set_aggregate!

  """
  fetch data from the table: "tile_set"
  """
  tileSets(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): [tile_set!]!

  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: uuid!): users
}

"""
columns and relationships of "tile_provider"
"""
type tile_provider {
  id: uuid!
  name: String!
  slug: String!

  """
  An array relationship
  """
  tileSets(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): [tile_set!]!

  """
  An aggregated array relationship
  """
  tileSets_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tile_set_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tile_set_order_by!]

    """
    filter the rows returned
    """
    where: tile_set_bool_exp
  ): tile_set_aggregate!
  url: String!
}

"""
aggregated selection of "tile_provider"
"""
type tile_provider_aggregate {
  aggregate: tile_provider_aggregate_fields
  nodes: [tile_provider!]!
}

"""
aggregate fields of "tile_provider"
"""
type tile_provider_aggregate_fields {
  count(columns: [tile_provider_select_column!], distinct: Boolean): Int
  max: tile_provider_max_fields
  min: tile_provider_min_fields
}

"""
order by aggregate values of table "tile_provider"
"""
input tile_provider_aggregate_order_by {
  count: order_by
  max: tile_provider_max_order_by
  min: tile_provider_min_order_by
}

"""
input type for inserting array relation for remote table "tile_provider"
"""
input tile_provider_arr_rel_insert_input {
  data: [tile_provider_insert_input!]!
  on_conflict: tile_provider_on_conflict
}

"""
Boolean expression to filter rows from the table "tile_provider". All fields are combined with a logical 'AND'.
"""
input tile_provider_bool_exp {
  _and: [tile_provider_bool_exp]
  _not: tile_provider_bool_exp
  _or: [tile_provider_bool_exp]
  id: uuid_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  tileSets: tile_set_bool_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "tile_provider"
"""
enum tile_provider_constraint {
  """
  unique or primary key constraint
  """
  tile_provider_name_key

  """
  unique or primary key constraint
  """
  tile_provider_pkey

  """
  unique or primary key constraint
  """
  tile_provider_slug_key
}

"""
input type for inserting data into table "tile_provider"
"""
input tile_provider_insert_input {
  id: uuid
  name: String
  slug: String
  tileSets: tile_set_arr_rel_insert_input
  url: String
}

"""
aggregate max on columns
"""
type tile_provider_max_fields {
  id: uuid
  name: String
  slug: String
  url: String
}

"""
order by max() on columns of table "tile_provider"
"""
input tile_provider_max_order_by {
  id: order_by
  name: order_by
  slug: order_by
  url: order_by
}

"""
aggregate min on columns
"""
type tile_provider_min_fields {
  id: uuid
  name: String
  slug: String
  url: String
}

"""
order by min() on columns of table "tile_provider"
"""
input tile_provider_min_order_by {
  id: order_by
  name: order_by
  slug: order_by
  url: order_by
}

"""
response of any mutation on the table "tile_provider"
"""
type tile_provider_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [tile_provider!]!
}

"""
input type for inserting object relation for remote table "tile_provider"
"""
input tile_provider_obj_rel_insert_input {
  data: tile_provider_insert_input!
  on_conflict: tile_provider_on_conflict
}

"""
on conflict condition type for table "tile_provider"
"""
input tile_provider_on_conflict {
  constraint: tile_provider_constraint!
  update_columns: [tile_provider_update_column!]!
  where: tile_provider_bool_exp
}

"""
ordering options when selecting data from "tile_provider"
"""
input tile_provider_order_by {
  id: order_by
  name: order_by
  slug: order_by
  tileSets_aggregate: tile_set_aggregate_order_by
  url: order_by
}

"""
primary key columns input for table: "tile_provider"
"""
input tile_provider_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tile_provider"
"""
enum tile_provider_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  slug

  """
  column name
  """
  url
}

"""
input type for updating data in table "tile_provider"
"""
input tile_provider_set_input {
  id: uuid
  name: String
  slug: String
  url: String
}

"""
update columns of table "tile_provider"
"""
enum tile_provider_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  slug

  """
  column name
  """
  url
}

"""
columns and relationships of "tile_set"
"""
type tile_set {
  """
  An object relationship
  """
  areaOfInterest: area_of_interest!
  areaOfInterestId: uuid!
  format: String!
  id: uuid!
  progress: Float
  quality: smallint
  size: Int

  """
  An object relationship
  """
  tileProvider: tile_provider!
  tileProviderId: uuid!
}

"""
aggregated selection of "tile_set"
"""
type tile_set_aggregate {
  aggregate: tile_set_aggregate_fields
  nodes: [tile_set!]!
}

"""
aggregate fields of "tile_set"
"""
type tile_set_aggregate_fields {
  avg: tile_set_avg_fields
  count(columns: [tile_set_select_column!], distinct: Boolean): Int
  max: tile_set_max_fields
  min: tile_set_min_fields
  stddev: tile_set_stddev_fields
  stddev_pop: tile_set_stddev_pop_fields
  stddev_samp: tile_set_stddev_samp_fields
  sum: tile_set_sum_fields
  var_pop: tile_set_var_pop_fields
  var_samp: tile_set_var_samp_fields
  variance: tile_set_variance_fields
}

"""
order by aggregate values of table "tile_set"
"""
input tile_set_aggregate_order_by {
  avg: tile_set_avg_order_by
  count: order_by
  max: tile_set_max_order_by
  min: tile_set_min_order_by
  stddev: tile_set_stddev_order_by
  stddev_pop: tile_set_stddev_pop_order_by
  stddev_samp: tile_set_stddev_samp_order_by
  sum: tile_set_sum_order_by
  var_pop: tile_set_var_pop_order_by
  var_samp: tile_set_var_samp_order_by
  variance: tile_set_variance_order_by
}

"""
input type for inserting array relation for remote table "tile_set"
"""
input tile_set_arr_rel_insert_input {
  data: [tile_set_insert_input!]!
  on_conflict: tile_set_on_conflict
}

"""
aggregate avg on columns
"""
type tile_set_avg_fields {
  progress: Float
  quality: Float
  size: Float
}

"""
order by avg() on columns of table "tile_set"
"""
input tile_set_avg_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

"""
Boolean expression to filter rows from the table "tile_set". All fields are combined with a logical 'AND'.
"""
input tile_set_bool_exp {
  _and: [tile_set_bool_exp]
  _not: tile_set_bool_exp
  _or: [tile_set_bool_exp]
  areaOfInterest: area_of_interest_bool_exp
  areaOfInterestId: uuid_comparison_exp
  format: String_comparison_exp
  id: uuid_comparison_exp
  progress: Float_comparison_exp
  quality: smallint_comparison_exp
  size: Int_comparison_exp
  tileProvider: tile_provider_bool_exp
  tileProviderId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tile_set"
"""
enum tile_set_constraint {
  """
  unique or primary key constraint
  """
  tile_set_pkey
}

"""
input type for incrementing integer column in table "tile_set"
"""
input tile_set_inc_input {
  progress: Float
  quality: smallint
  size: Int
}

"""
input type for inserting data into table "tile_set"
"""
input tile_set_insert_input {
  areaOfInterest: area_of_interest_obj_rel_insert_input
  areaOfInterestId: uuid
  format: String
  id: uuid
  progress: Float
  quality: smallint
  size: Int
  tileProvider: tile_provider_obj_rel_insert_input
  tileProviderId: uuid
}

"""
aggregate max on columns
"""
type tile_set_max_fields {
  areaOfInterestId: uuid
  format: String
  id: uuid
  progress: Float
  quality: smallint
  size: Int
  tileProviderId: uuid
}

"""
order by max() on columns of table "tile_set"
"""
input tile_set_max_order_by {
  areaOfInterestId: order_by
  format: order_by
  id: order_by
  progress: order_by
  quality: order_by
  size: order_by
  tileProviderId: order_by
}

"""
aggregate min on columns
"""
type tile_set_min_fields {
  areaOfInterestId: uuid
  format: String
  id: uuid
  progress: Float
  quality: smallint
  size: Int
  tileProviderId: uuid
}

"""
order by min() on columns of table "tile_set"
"""
input tile_set_min_order_by {
  areaOfInterestId: order_by
  format: order_by
  id: order_by
  progress: order_by
  quality: order_by
  size: order_by
  tileProviderId: order_by
}

"""
response of any mutation on the table "tile_set"
"""
type tile_set_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [tile_set!]!
}

"""
input type for inserting object relation for remote table "tile_set"
"""
input tile_set_obj_rel_insert_input {
  data: tile_set_insert_input!
  on_conflict: tile_set_on_conflict
}

"""
on conflict condition type for table "tile_set"
"""
input tile_set_on_conflict {
  constraint: tile_set_constraint!
  update_columns: [tile_set_update_column!]!
  where: tile_set_bool_exp
}

"""
ordering options when selecting data from "tile_set"
"""
input tile_set_order_by {
  areaOfInterest: area_of_interest_order_by
  areaOfInterestId: order_by
  format: order_by
  id: order_by
  progress: order_by
  quality: order_by
  size: order_by
  tileProvider: tile_provider_order_by
  tileProviderId: order_by
}

"""
primary key columns input for table: "tile_set"
"""
input tile_set_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tile_set"
"""
enum tile_set_select_column {
  """
  column name
  """
  areaOfInterestId

  """
  column name
  """
  format

  """
  column name
  """
  id

  """
  column name
  """
  progress

  """
  column name
  """
  quality

  """
  column name
  """
  size

  """
  column name
  """
  tileProviderId
}

"""
input type for updating data in table "tile_set"
"""
input tile_set_set_input {
  areaOfInterestId: uuid
  format: String
  id: uuid
  progress: Float
  quality: smallint
  size: Int
  tileProviderId: uuid
}

"""
aggregate stddev on columns
"""
type tile_set_stddev_fields {
  progress: Float
  quality: Float
  size: Float
}

"""
order by stddev() on columns of table "tile_set"
"""
input tile_set_stddev_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

"""
aggregate stddev_pop on columns
"""
type tile_set_stddev_pop_fields {
  progress: Float
  quality: Float
  size: Float
}

"""
order by stddev_pop() on columns of table "tile_set"
"""
input tile_set_stddev_pop_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

"""
aggregate stddev_samp on columns
"""
type tile_set_stddev_samp_fields {
  progress: Float
  quality: Float
  size: Float
}

"""
order by stddev_samp() on columns of table "tile_set"
"""
input tile_set_stddev_samp_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

"""
aggregate sum on columns
"""
type tile_set_sum_fields {
  progress: Float
  quality: smallint
  size: Int
}

"""
order by sum() on columns of table "tile_set"
"""
input tile_set_sum_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

"""
update columns of table "tile_set"
"""
enum tile_set_update_column {
  """
  column name
  """
  areaOfInterestId

  """
  column name
  """
  format

  """
  column name
  """
  id

  """
  column name
  """
  progress

  """
  column name
  """
  quality

  """
  column name
  """
  size

  """
  column name
  """
  tileProviderId
}

"""
aggregate var_pop on columns
"""
type tile_set_var_pop_fields {
  progress: Float
  quality: Float
  size: Float
}

"""
order by var_pop() on columns of table "tile_set"
"""
input tile_set_var_pop_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

"""
aggregate var_samp on columns
"""
type tile_set_var_samp_fields {
  progress: Float
  quality: Float
  size: Float
}

"""
order by var_samp() on columns of table "tile_set"
"""
input tile_set_var_samp_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

"""
aggregate variance on columns
"""
type tile_set_variance_fields {
  progress: Float
  quality: Float
  size: Float
}

"""
order by variance() on columns of table "tile_set"
"""
input tile_set_variance_order_by {
  progress: order_by
  quality: order_by
  size: order_by
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "users"
"""
type users {
  """
  An object relationship
  """
  account: auth_accounts

  """
  An array relationship
  """
  area_of_interests(
    """
    distinct select on columns
    """
    distinct_on: [area_of_interest_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [area_of_interest_order_by!]

    """
    filter the rows returned
    """
    where: area_of_interest_bool_exp
  ): [area_of_interest!]!

  """
  An aggregated array relationship
  """
  area_of_interests_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [area_of_interest_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [area_of_interest_order_by!]

    """
    filter the rows returned
    """
    where: area_of_interest_bool_exp
  ): area_of_interest_aggregate!
  avatar_url: String
  created_at: timestamptz!
  display_name: String
  id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  account: auth_accounts_bool_exp
  area_of_interests: area_of_interest_bool_exp
  avatar_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  display_name: String_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  account: auth_accounts_obj_rel_insert_input
  area_of_interests: area_of_interest_arr_rel_insert_input
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type users_max_fields {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  updated_at: order_by
}

"""
aggregate min on columns
"""
type users_min_fields {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""
ordering options when selecting data from "users"
"""
input users_order_by {
  account: auth_accounts_order_by
  area_of_interests_aggregate: area_of_interest_aggregate_order_by
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "users"
"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """
  column name
  """
  avatar_url

  """
  column name
  """
  created_at

  """
  column name
  """
  display_name

  """
  column name
  """
  id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "users"
"""
enum users_update_column {
  """
  column name
  """
  avatar_url

  """
  column name
  """
  created_at

  """
  column name
  """
  display_name

  """
  column name
  """
  id

  """
  column name
  """
  updated_at
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
